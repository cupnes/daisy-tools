# 演習問題

daisy-toolsの理解を深めるには試してみるのが一番です。ここではその参考になりそうな演習問題をまとめます。

## 演習1：daisy-toolsのセットアップとexit0で終了する実行バイナリ生成を試す

何はともあれ、daisy-toolsがどの様に動くものなのか、てっとりばやく試してみましょう。

「何もせず正常終了(ステータス0でexit)するだけのELFバイナリ」を生成してみます。

```bash
$ sudo apt install build-essential libc6 bash jq strace
$ git clone https://github.com/cupnes/daisy-tools.git
$ cd daisy-tools
$ make setup
諸々のファイルを配置した作業ディレクトリを~/dsy-workに作成する
$ cd ~/dsy-work
$ samples/setup-sample exit
実験用の諸々のファイルを配置する
$ bin/run
実行完了を待つ
$ ls out.cell
out.cell  # 目的の振る舞いをするように進化した細胞ファイル
$ cp out.cell cell/
$ bin/dsy-cell2elf out.cell out.elf  # 細胞ファイルをELFバイナリへ変換
$ chmod +x out.elf
$ strace ./out.elf
何もせず正常終了(ステータス0でexit)している事がわかる
```

## 演習2：細胞ファイルを手動で作ってみる

daisy-toolsは「細胞」や「化合物」といった要素をファイルで管理します。どれもファイルフォーマットとしては比較的簡単なもので、`echo`や`dd`などでバイナリを出力して手動で作成することも可能です。

ここでは簡単な「細胞ファイル」を手動で作成してみます。[細胞ファイルのファイルフォーマットのドキュメント](../file-format.md#%E7%B4%B0%E8%83%9E%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB)を参照し、手動で細胞ファイルを作成してみましょう。

内容は以降の演習や作成の手軽さから以下とします。以下で指定している他は何でも構いません。またここで指定している内容も大したものではないので、違う設定にした場合は以降の演習を適宜読み替えてください。

- 「属性情報」の「寿命」と「余命」は`10`くらいの少ない値にしておきます
  - 以降で、作成した細胞をdaisy-toolsで動作させ、死ぬ様子を観察するため
- 「DNA」には「ret命令(機械語:`0xc3`)」のコドン1つのみを配置しておきます
  - また、突然変異はこのコドンの直前への挿入のみ可とし、それ以外は不可としておきます
- 「タンパク質の列(機械語命令のバイナリ列)」もret命令のみとしておきます

作成したら、正しく認識できるか`dsy-dump-cell`で表示したり、`dsy-cell2elf`でELFへ変換した上で`dsy-elf2asm`で逆アセンブル表示したりしてみましょう。なお、ret命令のみの場合、実行すると`Segmentation fault`になります。(なのでsegvになるのは期待通りです。)

## 演習3：作成した細胞ファイルをdaisy-tools上で生きさせてみる

作成した細胞ファイルが正しく認識できることを確認できたら、daisy-toolsで動作させてみましょう。以下を試してみてください。

1. bin/dsy-evalを、常にステータス100を返す(適応度100を返す)ものへ差し替える
2. 作業ディレクトリ直下に`endless`という名前のファイルを配置し[エンドレスモード](https://github.com/cupnes/daisy-tools/blob/c77274f0034b0720c7b12a6833f4817830aab6af/docs/tips.md#%E9%81%A9%E5%BF%9C%E5%BA%A6100%E3%81%AE%E7%B4%B0%E8%83%9E%E3%81%8C%E7%94%9F%E3%81%BE%E3%82%8C%E3%81%A6%E3%82%82dsy-sysenv%E3%82%92%E7%B5%82%E4%BA%86%E3%81%95%E3%81%9B%E3%81%AA%E3%81%84%E3%81%A7%E5%8B%95%E4%BD%9C%E3%81%95%E3%81%9B%E7%B6%9A%E3%81%91%E3%82%8B%E6%96%B9%E6%B3%95%E3%82%A8%E3%83%B3%E3%83%89%E3%83%AC%E3%82%B9%E3%83%A2%E3%83%BC%E3%83%89)を設定する
3. 作業ディレクトリ(`dsy-work`)の`cell`ディレクトリと`code`ディレクトリの中を空にする
4. 作成した細胞ファイルを`cell`ディレクトリにコピー
   - ファイル名はASCII文字で付けてあれば何でも構いません
     - 付けなければならない拡張子とかもありません
     - ただ、ファイル名に関するテストをやっている訳ではないので、「記号だけ」とか変なファイル名を付けると思わぬ動作をするかもしれません
   - 元ファイルは作業ディレクトリ直下辺りにバックアップしておいてください
     - `cell`ディレクトリに置いておくと、寿命を迎えたら死んでしまうため
5. 別ターミナルで `watch -n 1 ls -l code cell` とかを実行してそれぞれのディレクトリをウォッチしておく
6. daisy-toolsを開始
7. 寿命が付きたら細胞が死んで、作った細胞ファイルは`cell`ディレクトリから無くなり、自身を構成していたコード化合物が`code`ディレクトリに置かれている事を観察

## 演習4：コード化合物ファイルを手動で作り、細胞分裂させてみる

続いて「コード化合物ファイル」を手動で作ってみます。[ファイルフォーマットのドキュメントはこちら](https://github.com/cupnes/daisy-tools/blob/97b49861a03bd37e6ba499f38d1bb6403f7db133/docs/file-format.md#%E3%82%B3%E3%83%BC%E3%83%89%E3%83%87%E3%83%BC%E3%82%BF%E5%8C%96%E5%90%88%E7%89%A9%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB)です。

内容としては、先程作成した細胞ファイルが増殖できるように、その細胞を構成するタンパク質(機械語命令)をそれぞれコード化合物として作成します。先程「ret命令だけ」の細胞ファイルを作成した場合、ret命令のコード化合物を作成します。

作成したら、以下の手順で動作させてみましょう。

1. 予め`code`ディレクトリと`cell`ディレクトリを空にしておく
2. 先程で作成した細胞ファイルを`cell`ディレクトリへ1つ配置
3. この演習で作成したコード化合物ファイルを`code`ディレクトリへ1つ配置
   - `code`ディレクトリに置いたコード化合物ファイルは、daisy-toolsを動作させると細胞に食べられた際に消えるので、作業ディレクトリ直下などへバックアップを取っておいてください
4. 別ターミナルで `watch -n 1 ls -l code cell` とかで観察
5. daisy-toolsを開始
6. コード化合物が食べられ、細胞分裂し、その後2つの細胞共に寿命を迎えて死ぬ様子を観察
7. また先程作成した細胞ファイルをcellディレクトリへ1つ配置
8. 先程の実行により、`code`ディレクトリにはこの演習で作成したコード化合物が2つ配置されている状態である事を確認
9. daisy-toolsを開始
10. コード化合物が食べられ、細胞分裂し、今度は細胞の数が最大3つになる事を確認
    - この様に、細胞を構成する必須のコード化合物の数で細胞の増殖を制限することができます

## 演習5：先程とは別のコード化合物ファイルを追加し、突然変異を観察

演習3や4でも起きてたかもしれませんが、これまでは環境上に存在するコード化合物がret命令のみだったので、ret命令の前にret命令が追加されるくらいでした。

明確に異なるコード化合物が突然変異によりDNAに組み込まれる様子を見てみましょう。

これ単体では全く無意味な命令ですが、RDIをゼロクリアする`xor %rdi,%rdi`のコード化合物を作ってみることにします。ファイル名は`xor_rdi_rdi.comp`とすることにします。

そして、以下の手順を試してみてください。

1. 予めcodeディレクトリとcellディレクトリを空にしておく
2. 演習2で作成した細胞ファイルをcellディレクトリへ1つ配置
3. 演習4で作成したコード化合物ファイルをcodeディレクトリへ100個配置
   - 突然変異は細胞分裂のタイミングで起こるので、ひたすら細胞分裂させる必要がある
4. この演習で作成したコード化合物をcodeディレクトリへ1つ配置
5. daisy-toolsを開始
6. 標準出力を観察し、突然変異が起きるのを待つ
7. 突然変異が起きたら、daisy-toolsを停止
8. 突然変異した細胞ファイルをdsy-dump-cellで観察
   - DNAの状態を見て、ret命令の直前にxor %rdi,%rdiが追加されていることを確認してみましょう
   - また、DNAのコドン数が増えたことで寿命が延びている事を確認してみましょう
9. 別ターミナルで `watch -n 1 ls -l cell/<突然変異した細胞ファイル> code/xor_rdi_rdi.comp` で観察
10. daisy-toolsを再開
11. この演習で作成し配置したコード化合物ファイルを、突然変異した細胞が食べるかどうか確認
    - xor_rdi_rdi.compを食べる前に死んでしまうかもしれませんが
    - もし食べたら、ret命令はおそらくすでに食べてるだろうから細胞分裂できるはず
    - ただ、それで分裂したとしても、xor_rdi_rdi.compのコード化合物はもうありません
    - 親が死んで、その死骸を子が食べるという連鎖がうまく行けばよいが、それがだめになった途端に絶滅します

## 演習6：dsy-evalで進化の方向性を設定する

先程の演習の場合、たとえxor_rdi_rdi.compのコード化合物ファイルを多数配置したとしても、xor_rdi_rdiを含むように進化した細胞が増えていくかどうかは分かりません。ret命令しか持っていない細胞の方がコドンが1つしかない分、細胞分裂し易いとも考えられます。

意図した進化を行った細胞を残していく仕組みとして`dsy-eval`があります。

演習3で設定したため、現状では`dsy-eval`は常に適応度100を返すようになっていますが、これを以下のように変更してみます。

- `dsy-dump-cell`の結果をパースし、xor_rdi_rdiを含んでいた場合、適応度100を返す
- そうでなければ適応度50を返す

そして、以下の手順を試してみます。

1. 予め`code`ディレクトリと`cell`ディレクトリを空にしておく
2. 演習2で作成した細胞ファイルを`cell`ディレクトリへ1つ配置
3. 演習4と5で作成したコード化合物ファイルを`code`ディレクトリへ100個ずつ配置
4. daisy-toolsを開始
5. 適応度100の細胞が生まれ、daisy-toolsが停止するのを待つ
6. `log`ディレクトリ以下のHTMLを見て、適応度100の細胞が1つ居る事を確認
7. `bin/run`で`bin/cell-fitness-logger`の引数に60を設定し、60秒周期でHTMLログが生成されるようにする
   - `bin/cell-fitness-logger`自体もシェルスクリプトで、中を見ればusageについて書かれています
8. `endless`ファイルを配置
9. daisy-toolsを再開
10. 適応度100の細胞が増えていく様子を観察

## 演習7：ELF実行ファイルを手動で作ってみる

今度は変わって、ELFファイルを手動で作ってみます。

daisy-toolsでは`dsy-cell2elf`によって最低限のヘッダのみを持ったELFファイルを生成しています。機械語命令のバイナリ列自体はあるので、それをロードして実行するのに必要な最低限のELFヘッダを付ける、という方針です。

`dsy-cell2elf`のソースコードを元に、最低限設定を行ったELFヘッダを生成するコードをこの`exercise`ディレクトリに`create-elf-header.c`というファイル名で置いています。ここではそれを使ってELFヘッダを生成し、手書きで作成した機械語バイナリ列と`cat`コマンドで結合して実行してみましょう。なお、ELFファイルフォーマットについて詳しくは[man 5 elf](https://linuxjm.osdn.jp/html/LDP_man-pages/man5/elf.5.html)などを参照してください。

以下の手順で試してみてください。

1. `create-elf-header.c`をコンパイルして実行ファイル(`create-elf-header`)作成
   - `Makefile`が置いてあります
2. ステータス0でexitするだけの機械語バイナリ列のファイル作成
   - 例)
     ```bash
     $ echo -en '\x48\x31\xff' >xor_rdi_rdi.code
     $ echo -en '\x48\x31\xc0' >xor_rax_rax.code
     $ echo -en '\xb0\x3c' >mov_60_al.code
     $ echo -en '\x0f\x05' >syscall.code
     $ echo -en '\xc3' >ret.code
     $ cat xor_rdi_rdi.code xor_rax_rax.code mov_60_al.code syscall.code ret.code >codes.dat
     ```
3. 作成した機械語バイナリファイルのファイルサイズを確認
   - 11バイトであるはず
4. `create-elf-header`でELFヘッダファイル作成
   - 第1引数に機械語バイナリのファイルサイズ、第2引数に出力ファイル名を指定します
   - 例) `./create-elf-header 11 head.dat`
5. `head.dat`と`codes.dat`を`cat`コマンドで結合しELFファイル作成
6. 作成したELFファイルを実行し、意図通りであるか確認
   - `strace`を使ってELFバイナリが発行しているシステムコールが意図通りか見てみましょう

## 演習8：初期設計の代謝を試す

細胞の代謝/運動(実行と評価)に`dsy-eval`を使用する現在の設計では使用しなくなりましたが、初期設計では「代謝」として細胞の実行時に引数を指定したり戻り値を取得したりすることができました。以前の話として、ELFファイルを生成するようになる前は、細胞を実行する際は機械語バイナリ列を関数呼び出しで実行していました。その際、`data`ディレクトリに配置された「データ化合物ファイル」から取得した値を引数として使用することができました。それを「関数に引数が合成される」ということで生物における「同化」と見立て、また、関数実行後に戻り値が返ってくる事を「異化」と見立てて、「同化」・「異化」ができることから引数を指定して関数を実行し戻り値が返ってくる一連の動作を「代謝」と見立てました。この設計については[同人誌「バイナリ生物学入門」でも紹介しています](http://yuma.ohgami.jp/Intelligent-Life-in-the-Binary/02_design_model.html#id_01_act_meta_moti)のでよろしければ詳しくはそちらをご覧ください。

実は、当初の代謝設計の実装がまだ残っています。cell.cに`cell_exec()`という関数がありますが、実はこれは今は一切呼ばれません。この関数を呼び出しているところを探すと、dsy-exec-cell.cというソースコードが見つかります。これが当初の代謝/運動の設計を実装した部分です。dsy-exec-cell.cの`main()`でやっている内容がcell.cの`cell_do_cycle()`の「代謝/運動」でやっていることに相当します。

`dsy-exec-cell`は単体で実行できるので、`cell`・`data`のディレクトリに適宜ファイルを置いて、当初の設計の代謝/運動の様子を観察してみましょう。なお、daisy-toolsの初期設計の代謝の仕組みで関数へ引数を渡して実行しているので、この細胞ファイルはELFへ変換できません。

また、作業ディレクトリの`bin/dsy-eval`をこの`dsy-exec-cell`へ置き換えれば、初期設計の代謝の仕組みでdaisy-toolsを動作させる事も可能です。ただし、当時は「適応度」の仕組みが無く、`dsy-exec-cell`は常に`EXIT_SUCCESS`(終了ステータス`0`)を返してしまいます。そこだけは書き換えて何らかの適応度を終了ステータスで返す様にする必要があります。評価の仕組みも実装して適応度を適切に返すようにするか、まずは死なない程度に適応度`80`を常に返す、とかで構いません。
